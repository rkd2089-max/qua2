<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>질문 상세 - Q&A 게시판</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="container">
      <h1>Q&A 게시판</h1>
    </div>
  </header>

  <div class="container">
    <!-- 질문 상세 -->
    <div class="question-detail" id="questionDetail"></div>

    <!-- 답변 섹션 -->
    <div class="answers-section" id="answers-section">
      <div class="answers-header">답변</div>

      <!-- 답변 목록 -->
      <div class="answer-list" id="answerList"></div>

      <!-- 답변 작성 폼 -->
      <div class="answer-form">
        <h3 style="margin-bottom: 15px; color: #2c3e50;">답변 작성</h3>
        <form id="answerForm" onsubmit="submitAnswer(event)">
          <div class="form-group">
            <label for="answerNickname">닉네임 *</label>
            <input type="text" id="answerNickname" required placeholder="닉네임을 입력하세요">
          </div>
          <div class="form-group">
            <label for="answerContent">답변 내용 *</label>
            <textarea id="answerContent" required placeholder="답변 내용을 입력하세요" style="min-height: 150px;"></textarea>
          </div>
          <div class="form-actions">
            <button type="submit" class="btn btn-primary">답변 등록</button>
          </div>
        </form>
      </div>
    </div>

    <!-- 빈 상태 메시지 -->
    <div class="empty-state" id="emptyState" style="display: none;">
      <div class="empty-state-icon">❓</div>
      <div class="empty-state-message">존재하지 않는 질문입니다.</div>
      <button class="btn btn-primary" onclick="location.href='index.html'" style="margin-top: 20px;">목록으로 돌아가기</button>
    </div>
  </div>

  <!-- 삭제 확인 모달 -->
  <div id="deleteModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">삭제 확인</div>
      <div class="modal-body">
        <p>삭제하려면 비밀번호를 입력하세요.</p>
        <input type="password" id="deletePassword" placeholder="비밀번호 입력" style="width: 100%; padding: 10px; margin-top: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <p id="deleteError" style="color: #e74c3c; margin-top: 10px; display: none;">비밀번호가 일치하지 않습니다.</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeDeleteModal()">취소</button>
        <button class="btn btn-danger" onclick="confirmDelete()">삭제</button>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- Firebase 설정 -->
  <script src="firebase-config.js"></script>

  <script>
    let currentQuestionId = null;
    let currentDeleteId = null;
    let currentDeleteType = null;

    document.addEventListener('DOMContentLoaded', () => {
      const urlParams = new URLSearchParams(window.location.search);
      currentQuestionId = urlParams.get('id');

      if (currentQuestionId) {
        loadQuestionDetail(currentQuestionId);
        loadAnswers(currentQuestionId); // 실시간 답변 로딩
      } else {
        showEmptyState();
      }
    });

    async function loadQuestionDetail(questionId) {
      try {
        const doc = await db.collection('questions').doc(questionId).get();
        if (!doc.exists) return showEmptyState();

        const question = doc.data();
        const questionDetail = document.getElementById('questionDetail');

        // 조회수 증가
        await db.collection('questions').doc(questionId).update({
          viewCount: firebase.firestore.FieldValue.increment(1)
        });

        const updatedDoc = await db.collection('questions').doc(questionId).get();
        const updatedQuestion = updatedDoc.data();

        const categoryBadge = question.category ? `<span class="question-category">${question.category}</span>` : '';

        questionDetail.innerHTML = `
          <div class="question-detail-header">
            <div class="question-detail-title">${escapeHtml(question.title)}${categoryBadge}</div>
            <div class="question-detail-meta">
              <span>작성자: ${escapeHtml(question.nickname)}</span>
              <span>작성일: ${formatDate(question.createdAt?.toDate() || new Date())}</span>
              <span>조회수: ${updatedQuestion.viewCount || 0}</span>
            </div>
          </div>
          <div class="question-detail-content">${escapeHtml(question.content)}</div>
          <div class="question-actions">
            <button class="btn btn-secondary" onclick="location.href='index.html'">목록으로</button>
            <button class="btn btn-danger" onclick="openDeleteModal('${questionId}', 'question')">질문 삭제</button>
          </div>
        `;
      } catch (error) {
        console.error('질문 상세 불러오기 실패:', error);
        alert('질문을 불러오는 중 오류가 발생했습니다.');
      }
    }

    function loadAnswers(questionId) {
      const answerList = document.getElementById('answerList');

      // orderBy 없이 조회 (복합 인덱스 불필요) → 가져온 뒤 작성일 오래된 순으로 정렬
      db.collection('answers')
        .where('questionId', '==', questionId)
        .onSnapshot(snapshot => {
          answerList.innerHTML = '';

          if (snapshot.empty) {
            answerList.innerHTML = '<div class="empty-state" style="padding: 40px;"><div class="empty-state-message">아직 답변이 없습니다.</div></div>';
            return;
          }

          const docs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          docs.sort((a, b) => {
            const timeA = a.createdAt && a.createdAt.toDate ? a.createdAt.toDate().getTime() : 0;
            const timeB = b.createdAt && b.createdAt.toDate ? b.createdAt.toDate().getTime() : 0;
            return timeA - timeB; // 오래된 순
          });

          docs.forEach(({ id, ...answer }) => {
            const answerCard = createAnswerCard(id, answer);
            answerList.appendChild(answerCard);
          });
        }, err => {
          console.error('답변 목록 불러오기 실패:', err);
          document.getElementById('answerList').innerHTML = '<div class="empty-state" style="padding: 40px;"><div class="empty-state-message">답변을 불러오지 못했습니다.</div></div>';
        });
    }

    function createAnswerCard(id, answer) {
      const card = document.createElement('div');
      card.className = 'answer-card';

      const createdAtDate = answer.createdAt?.toDate() || new Date();

      card.innerHTML = `
        <div class="answer-header">
          <span class="answer-author">${escapeHtml(answer.nickname)}</span>
          <span class="answer-date">${formatDate(createdAtDate)}</span>
        </div>
        <div class="answer-content">${escapeHtml(answer.content)}</div>
        <div class="answer-actions">
          <button class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;" onclick="event.stopPropagation(); openDeleteModal('${id}', 'answer')">삭제</button>
        </div>
      `;

      return card;
    }

    async function submitAnswer(event) {
      event.preventDefault();
      if (!currentQuestionId) {
        alert('질문 정보를 불러올 수 없습니다.');
        return;
      }

      const nickname = document.getElementById('answerNickname').value.trim();
      const content = document.getElementById('answerContent').value.trim();
      if (!nickname || !content) {
        alert('닉네임과 답변 내용을 입력해주세요.');
        return;
      }

      const submitBtn = document.querySelector('#answerForm button[type="submit"]');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = '등록 중...';

      try {
        await db.collection('answers').add({
          questionId: currentQuestionId,
          nickname: nickname,
          content: content,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        document.getElementById('answerForm').reset();
        alert('답변이 등록되었습니다.');
      } catch (error) {
        console.error('답변 등록 실패:', error);
        let msg = '답변 등록 중 오류가 발생했습니다.';
        if (error.code === 'permission-denied') {
          msg = '권한이 없습니다. Firebase 콘솔 → Firestore → 규칙에서 읽기/쓰기를 허용해주세요.';
        } else if (error.message) {
          msg += ' (' + error.message + ')';
        }
        alert(msg);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    function showEmptyState() {
      document.getElementById('questionDetail').style.display = 'none';
      document.getElementById('answers-section').style.display = 'none';
      document.getElementById('emptyState').style.display = 'block';
    }

    function openDeleteModal(id, type) {
      currentDeleteId = id;
      currentDeleteType = type;
      document.getElementById('deleteModal').style.display = 'block';
      document.getElementById('deletePassword').value = '';
      document.getElementById('deleteError').style.display = 'none';
      document.getElementById('deletePassword').focus();
    }

    function closeDeleteModal() {
      document.getElementById('deleteModal').style.display = 'none';
      currentDeleteId = null;
      currentDeleteType = null;
    }

    async function confirmDelete() {
      const password = document.getElementById('deletePassword').value;
      const deleteError = document.getElementById('deleteError');
      const correctPassword = 'jz2073jz';

      if (password !== correctPassword) {
        deleteError.style.display = 'block';
        return;
      }

      try {
        if (currentDeleteType === 'question') {
          const answersSnapshot = await db.collection('answers')
            .where('questionId', '==', currentDeleteId)
            .get();
          const deletePromises = answersSnapshot.docs.map(doc => doc.ref.delete());
          await Promise.all(deletePromises);

          await db.collection('questions').doc(currentDeleteId).delete();
          alert('질문이 삭제되었습니다.');
          location.href = 'index.html';
        } else if (currentDeleteType === 'answer') {
          await db.collection('answers').doc(currentDeleteId).delete();
          alert('답변이 삭제되었습니다.');
        }

        closeDeleteModal();
      } catch (error) {
        console.error('삭제 실패:', error);
        alert('삭제 중 오류가 발생했습니다.');
      }
    }

    window.onclick = function(event) {
      const modal = document.getElementById('deleteModal');
      if (event.target === modal) closeDeleteModal();
    }

    // 유틸 함수: HTML escape
    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // 유틸 함수: 날짜 포맷
    function formatDate(date) {
      const d = new Date(date);
      return `${d.getFullYear()}-${(d.getMonth()+1).toString().padStart(2,'0')}-${d.getDate().toString().padStart(2,'0')} ${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
    }
  </script>
</body>
</html>
