<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>질문 상세 - Q&A 게시판</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="container">
      <h1>Q&A 게시판</h1>
    </div>
  </header>

  <div class="container">
    <!-- 질문 상세 -->
    <div class="question-detail" id="questionDetail">
      <!-- 질문 내용이 여기에 동적으로 추가됩니다 -->
    </div>

    <!-- 답변 섹션 -->
    <div class="answers-section" id="answers-section">
      <div class="answers-header">답변</div>
      
      <!-- 답변 목록 -->
      <div class="answer-list" id="answerList">
        <!-- 답변들이 여기에 동적으로 추가됩니다 -->
      </div>
      
      <!-- 답변 작성 폼 -->
      <div class="answer-form">
        <h3 style="margin-bottom: 15px; color: #2c3e50;">답변 작성</h3>
        <form id="answerForm" onsubmit="submitAnswer(event)">
          <div class="form-group">
            <label for="answerNickname">닉네임 *</label>
            <input type="text" id="answerNickname" required placeholder="닉네임을 입력하세요">
          </div>
          <div class="form-group">
            <label for="answerContent">답변 내용 *</label>
            <textarea id="answerContent" required placeholder="답변 내용을 입력하세요" style="min-height: 150px;"></textarea>
          </div>
          <div class="form-actions">
            <button type="submit" class="btn btn-primary">답변 등록</button>
          </div>
        </form>
      </div>
    </div>

    <!-- 빈 상태 메시지 -->
    <div class="empty-state" id="emptyState" style="display: none;">
      <div class="empty-state-icon">❓</div>
      <div class="empty-state-message">존재하지 않는 질문입니다.</div>
      <button class="btn btn-primary" onclick="location.href='index.html'" style="margin-top: 20px;">목록으로 돌아가기</button>
    </div>
  </div>

  <!-- 삭제 확인 모달 -->
  <div id="deleteModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">삭제 확인</div>
      <div class="modal-body">
        <p>삭제하려면 비밀번호를 입력하세요.</p>
        <input type="password" id="deletePassword" placeholder="비밀번호 입력" style="width: 100%; padding: 10px; margin-top: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <p id="deleteError" style="color: #e74c3c; margin-top: 10px; display: none;">비밀번호가 일치하지 않습니다.</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeDeleteModal()">취소</button>
        <button class="btn btn-danger" onclick="confirmDelete()">삭제</button>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  
  <!-- 설정 및 스크립트 -->
  <script src="firebase-config.js"></script>
  <script src="script.js"></script>
  <script>
    let currentQuestionId = null;
    let currentDeleteId = null;
    let currentDeleteType = null;

    // 페이지 로드 시 질문 상세 불러오기
    document.addEventListener('DOMContentLoaded', () => {
      const urlParams = new URLSearchParams(window.location.search);
      currentQuestionId = urlParams.get('id');
      
      if (currentQuestionId) {
        loadQuestionDetail(currentQuestionId);
        loadAnswers(currentQuestionId);
      } else {
        showEmptyState();
      }
    });

    // 질문 상세 불러오기
    async function loadQuestionDetail(questionId) {
      try {
        const doc = await db.collection('questions').doc(questionId).get();
        
        if (!doc.exists) {
          showEmptyState();
          return;
        }
        
        const question = doc.data();
        const questionDetail = document.getElementById('questionDetail');
        
        // 조회수 증가
        await db.collection('questions').doc(questionId).update({
          viewCount: firebase.firestore.FieldValue.increment(1)
        });
        
        // 조회수 표시를 위해 다시 불러오기
        const updatedDoc = await db.collection('questions').doc(questionId).get();
        const updatedQuestion = updatedDoc.data();
        
        const categoryBadge = question.category ? `<span class="question-category">${question.category}</span>` : '';
        
        questionDetail.innerHTML = `
          <div class="question-detail-header">
            <div class="question-detail-title">${escapeHtml(question.title)}${categoryBadge}</div>
            <div class="question-detail-meta">
              <span>작성자: ${escapeHtml(question.nickname)}</span>
              <span>작성일: ${formatDate(question.createdAt)}</span>
              <span>조회수: ${updatedQuestion.viewCount || 0}</span>
            </div>
          </div>
          <div class="question-detail-content">${escapeHtml(question.content)}</div>
          <div class="question-actions">
            <button class="btn btn-secondary" onclick="location.href='index.html'">목록으로</button>
            <button class="btn btn-danger" onclick="openDeleteModal('${questionId}', 'question')">질문 삭제</button>
          </div>
        `;
      } catch (error) {
        console.error('질문 상세 불러오기 실패:', error);
        alert('질문을 불러오는 중 오류가 발생했습니다.');
      }
    }

    // 답변 목록 불러오기
    async function loadAnswers(questionId) {
      try {
        const snapshot = await db.collection('answers')
          .where('questionId', '==', questionId)
          .orderBy('createdAt', 'asc')
          .get();
        
        const answerList = document.getElementById('answerList');
        answerList.innerHTML = '';
        
        if (snapshot.empty) {
          answerList.innerHTML = '<div class="empty-state" style="padding: 40px;"><div class="empty-state-message">아직 답변이 없습니다.</div></div>';
          return;
        }
        
        snapshot.forEach(doc => {
          const answer = doc.data();
          const answerCard = createAnswerCard(doc.id, answer);
          answerList.appendChild(answerCard);
        });
      } catch (error) {
        console.error('답변 목록 불러오기 실패:', error);
        // createdAt 필드가 없을 수 있으므로 인덱스 오류는 무시
        if (error.code !== 'failed-precondition') {
          alert('답변 목록을 불러오는 중 오류가 발생했습니다.');
        }
      }
    }

    // 답변 카드 생성
    function createAnswerCard(id, answer) {
      const card = document.createElement('div');
      card.className = 'answer-card';
      
      card.innerHTML = `
        <div class="answer-header">
          <span class="answer-author">${escapeHtml(answer.nickname)}</span>
          <span class="answer-date">${formatDate(answer.createdAt)}</span>
        </div>
        <div class="answer-content">${escapeHtml(answer.content)}</div>
        <div class="answer-actions">
          <button class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;" onclick="event.stopPropagation(); openDeleteModal('${id}', 'answer')">삭제</button>
        </div>
      `;
      
      return card;
    }

    // 답변 등록
    async function submitAnswer(event) {
      event.preventDefault();
      
      if (!currentQuestionId) {
        alert('질문 정보를 불러올 수 없습니다.');
        return;
      }
      
      const nickname = document.getElementById('answerNickname').value.trim();
      const content = document.getElementById('answerContent').value.trim();
      
      if (!nickname || !content) {
        alert('닉네임과 답변 내용을 입력해주세요.');
        return;
      }
      
      try {
        await db.collection('answers').add({
          questionId: currentQuestionId,
          nickname: nickname,
          content: content,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        document.getElementById('answerForm').reset();
        alert('답변이 등록되었습니다.');
        loadAnswers(currentQuestionId);
      } catch (error) {
        console.error('답변 등록 실패:', error);
        alert('답변 등록 중 오류가 발생했습니다.');
      }
    }

    // 빈 상태 표시
    function showEmptyState() {
      document.getElementById('questionDetail').style.display = 'none';
      document.getElementById('answers-section').style.display = 'none';
      document.getElementById('emptyState').style.display = 'block';
    }

    // 삭제 모달 열기
    function openDeleteModal(id, type) {
      currentDeleteId = id;
      currentDeleteType = type;
      document.getElementById('deleteModal').style.display = 'block';
      document.getElementById('deletePassword').value = '';
      document.getElementById('deleteError').style.display = 'none';
      document.getElementById('deletePassword').focus();
    }

    // 삭제 모달 닫기
    function closeDeleteModal() {
      document.getElementById('deleteModal').style.display = 'none';
      currentDeleteId = null;
      currentDeleteType = null;
    }

    // 삭제 확인
    async function confirmDelete() {
      const password = document.getElementById('deletePassword').value;
      const deleteError = document.getElementById('deleteError');
      const correctPassword = 'jz2073jz';
      
      if (password !== correctPassword) {
        deleteError.style.display = 'block';
        return;
      }
      
      try {
        if (currentDeleteType === 'question') {
          // 질문 삭제 시 관련 답변도 모두 삭제
          const answersSnapshot = await db.collection('answers')
            .where('questionId', '==', currentDeleteId)
            .get();
          
          const deletePromises = answersSnapshot.docs.map(doc => doc.ref.delete());
          await Promise.all(deletePromises);
          
          await db.collection('questions').doc(currentDeleteId).delete();
          alert('질문이 삭제되었습니다.');
          location.href = 'index.html';
        } else if (currentDeleteType === 'answer') {
          await db.collection('answers').doc(currentDeleteId).delete();
          alert('답변이 삭제되었습니다.');
          loadAnswers(currentQuestionId);
        }
        
        closeDeleteModal();
      } catch (error) {
        console.error('삭제 실패:', error);
        alert('삭제 중 오류가 발생했습니다.');
      }
    }

    // 모달 외부 클릭 시 닫기
    window.onclick = function(event) {
      const modal = document.getElementById('deleteModal');
      if (event.target === modal) {
        closeDeleteModal();
      }
    }
  </script>
</body>
</html>
